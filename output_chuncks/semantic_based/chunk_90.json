{
    "content": "Comprobar queries de base de datos lentas\n\nSoluciones:\n\nSoluci\u00f3n 1: Optimizaci\u00f3n de Queries\n\n-- Antes (query lenta)\nSELECT * FROM usuarios u \nJOIN pedidos p ON u.id = p.usuario_id \nWHERE u.activo = 1;\n\n-- Despu\u00e9s (query optimizada con \u00edndices)\nSELECT u.id, u.nombre, p.total \nFROM usuarios u \nJOIN pedidos p ON u.id = p.usuario_id \nWHERE u.activo = 1 \nAND u.fecha_creacion > '2024-01-01';\n\n-- Agregar \u00edndice\nCREATE INDEX idx_usuarios_activo_fecha ON usuarios(activo, fecha_creacion);\n\nSoluci\u00f3n 2: Implementar Cach\u00e9\n\nimport redis\nfrom functools import wraps\n\ndef cache_result(expiration=300):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            cache_key = f\"{func.__name__}:{hash(str(args) + str(kwargs))}\"\n\n            # Intentar obtener del cach\u00e9\n            cached_result = redis_client.get(cache_key)\n            if cached_result:\n                return json.loads(cached_result)\n\n            # Ejecutar funci\u00f3n y guardar en cach\u00e9\n            result = func(*args, **kwargs)\n            redis_client.setex(cache_key, expiration, json.dumps(result))\n            return result\n        return wrapper\n    return decorator\n\nSoluci\u00f3n 3: Conexi\u00f3n Pool de Base de Datos\n\n# Configuraci\u00f3n optimizada de conexiones\nDATABASE_CONFIG = {\n    'pool_size': 20,\n    'max_overflow': 30,\n    'pool_timeout': 30,\n    'pool_recycle': 3600,\n    'pool_pre_ping': True\n}\n\nPROBLEMA: Memory Leaks en aplicaci\u00f3n Node.js\n\nS\u00edntomas: - Uso de memoria crece constantemente - Performance degradada en el tiempo - Eventual crash por falta de memoria\n\nDiagn\u00f3stico:\n\n# Monitorear uso de memoria\nnode --inspect --max-old-space-size=4096 app.js\n\n# Generar heap dump\nkill -USR2 <node_process_id>\n\n# Analizar con herramientas\nnode --prof app.js\nnode --prof-process isolate-0x[...].log > profile.txt\n\nSoluciones:\n\nSoluci\u00f3n 1: Limpiar Event Listeners\n\n// Problem\u00e1tico\nclass MyComponent {\n    constructor() {\n        window.addEventListener('resize', this.handleResize);\n    }\n}\n\n// Correcto\nclass MyComponent {\n    constructor() {\n        this.handleResize = this.handleResize.bind(this);\n        window.addEventListener('resize', this.handleResize);\n    }\n\n    destroy() {\n        window.removeEventListener('resize', this.handleResize);\n    }\n}\n\nSoluci\u00f3n 2: Gesti\u00f3n de Streams\n\n// Problem\u00e1tico\nconst fs = require('fs');\nconst stream = fs.createReadStream('large-file.txt');\n// Stream nunca se cierra\n\n// Correcto\nconst fs = require('fs');\nconst stream = fs.createReadStream('large-file.txt');\nstream.on('end', () => stream.close());\nstream.on('error', () => stream.close());\n\nProblemas de Conectividad\n\nPROBLEMA: Errores de conexi\u00f3n a base de datos\n\nS\u00edntomas: - Error: \"Connection refused\" - Error: \"Too many connections\" - Timeouts intermitentes\n\nDiagn\u00f3stico:\n\n# Verificar conectividad\ntelnet db-server 5432\n\n# Verificar conexiones activas\npsql -c \"SELECT count(*) FROM pg_stat_activity;\"\n\n# Revisar logs de PostgreSQL\ntail -f /var/log/postgresql/postgresql.log\n\nSoluciones:\n\nSoluci\u00f3n 1: Configurar Connection Pooling\n\nimport psycopg2.pool\n\n# Crear pool de conexiones\nconnection_pool = psycopg2.pool.ThreadedConnectionPool(\n    minconn=5,\n    maxconn=20,\n    host=\"localhost\",\n    database=\"mydb\",\n    user=\"user\",\n    password=\"password\"\n)\n\ndef get_db_connection():\n    return connection_pool.getconn()\n\ndef release_db_connection(conn):\n    connection_pool.putconn(conn)\n\nSoluci\u00f3n 2: Implementar Circuit Breaker\n\nclass CircuitBreaker:\n    def __init__(self, failure_threshold=5, timeout=60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN\n\n    def call(self, func, *args, **kwargs):\n        if self.state == 'OPEN':\n            if time.time() - self.last_failure_time > self.timeout:\n                self.state = 'HALF_OPEN'\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n\n        try:\n            result = func(*args, **kwargs)\n            self.failure_count = 0\n            self.state = 'CLOSED'\n            return result\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = time.time()\n\n            if self.failure_count >= self.failure_threshold:\n                self.state = 'OPEN'\n\n            raise e\n\nPROBLEMA: SSL/TLS Certificate Errors\n\nS\u00edntomas: - Error: \"certificate verify failed\" - Error: \"SSL handshake failed\" - Browsers showing security warnings\n\nDiagn\u00f3stico:\n\n# Verificar certificado\nopenssl s_client -connect example.com:443 -servername example.com\n\n# Verificar fechas de expiraci\u00f3n\necho | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -dates\n\n# Verificar cadena de certificados\nopenssl verify -CAfile ca-bundle.crt certificate.crt\n\nSoluciones:\n\nSoluci\u00f3n 1: Renovar Certificado con Let's Encrypt\n\n# Installar certbot\nsudo apt-get install certbot python3-certbot-nginx\n\n# Obtener certificado\nsudo certbot --nginx -d example.com\n\n# Configurar renovaci\u00f3n autom\u00e1tica\nsudo crontab -e\n# Agregar l\u00ednea:\n0 12 * * * /usr/bin/certbot renew --quiet\n\nSoluci\u00f3n 2: Configurar Nginx para SSL\n\nserver {\n    listen 443 ssl http2;\n    server_name example.com;\n\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;\n    ssl_prefer_server_ciphers off;\n\n    # Security headers\n    add_header Strict-Transport-Security \"max-age=63072000\" always;\n    add_header X-Frame-Options DENY;\n    add_header X-Content-Type-Options nosniff;\n}\n\nProblemas de Deployment\n\nPROBLEMA: Docker containers failing to start\n\nS\u00edntomas: - Container exits immediately - Error: \"standard_init_linux.go: exec user process caused: no such file or directory\" - Health checks failing\n\nDiagn\u00f3stico:\n\n# Verificar logs del container\ndocker logs container_name\n\n# Inspeccionar container\ndocker inspect container_name\n\n# Ejecutar shell en container para debug\ndocker run -it --entrypoint /bin/sh image_name\n\n# Verificar recursos del sistema\ndocker stats\n\nSoluciones:\n\nSoluci\u00f3n 1: Corregir Dockerfile\n\n# Problem\u00e1tico\nFROM node:alpine\nCOPY .",
    "metadata": {
        "source": "data/troubleshooting_guide.md",
        "doc_index": 4,
        "chunk_index": 90,
        "start_sentence_index": 4,
        "end_sentence_index": 4
    }
}