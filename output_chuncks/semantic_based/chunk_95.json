{
    "content": "ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n        reservations:\n          cpus: '0.25'\n          memory: 256M\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\nPROBLEMA: Kubernetes Pods in CrashLoopBackOff\n\nS\u00edntomas: - Pods reiniciando constantemente - Status: CrashLoopBackOff - Application not accessible\n\nDiagn\u00f3stico:\n\n# Verificar status de pods\nkubectl get pods\n\n# Verificar logs\nkubectl logs pod-name --previous\n\n# Describir pod para eventos\nkubectl describe pod pod-name\n\n# Verificar recursos del nodo\nkubectl top nodes\nkubectl top pods\n\nSoluciones:\n\nSoluci\u00f3n 1: Ajustar Resource Limits\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: app\n        image: my-app:latest\n        ports:\n        - containerPort: 3000\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        # Probes para verificar salud\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\nSoluci\u00f3n 2: Configurar Startup Probe para aplicaciones lentas\n\ncontainers:\n- name: app\n  image: my-app:latest\n  startupProbe:\n    httpGet:\n      path: /startup\n      port: 3000\n    failureThreshold: 30\n    periodSeconds: 10\n  livenessProbe:\n    httpGet:\n      path: /health\n      port: 3000\n    periodSeconds: 10\n  readinessProbe:\n    httpGet:\n      path: /ready\n      port: 3000\n    periodSeconds: 5\n\nHerramientas de Monitoreo y Debug\n\nComandos \u00datiles para Diagnostico\n\nSystem Resources:\n\n# CPU y memoria\nhtop\n# o\ntop -p `pgrep -d',' node`\n\n# Espacio en disco\ndf -h\ndu -sh /var/log/*\n\n# Conexiones de red\nnetstat -tulpn | grep :3000\nss -tulpn | grep :3000\n\n# Procesos que usan m\u00e1s memoria\nps aux --sort=-%mem | head\n\n# I/O de disco\niotop\n\nApplication Logs:\n\n# Seguir logs en tiempo real\ntail -f /var/log/app/application.log\n\n# Buscar errores en logs\ngrep -i error /var/log/app/application.log | tail -20\n\n# Contar errores por hora\ngrep -i error /var/log/app/application.log | awk '{print $1\" \"$2}' | sort | uniq -c\n\n# Analizar logs con jq (para JSON logs)\ncat app.log | jq 'select(.level == \"error\")'\n\nScripts de Monitoreo Automatizado\n\nHealth Check Script:\n\n#!/bin/bash\n\n# Script de health check autom\u00e1tico\nENDPOINT=\"http://localhost:3000/health\"\nMAX_RETRIES=3\nRETRY_COUNT=0\n\nwhile [ $RETRY_COUNT -lt $MAX_RETRIES ]; do\n    RESPONSE=$(curl -s -o /dev/null -w \"%{http_code}\" $ENDPOINT)\n\n    if [ $RESPONSE -eq 200 ]; then\n        echo \"$(date): Service is healthy\"\n        exit 0\n    else\n        echo \"$(date): Health check failed with code $RESPONSE\"\n        RETRY_COUNT=$((RETRY_COUNT + 1))\n        sleep 5\n    fi\ndone\n\necho \"$(date): Service is unhealthy after $MAX_RETRIES attempts\"\n# Aqu\u00ed se puede agregar l\u00f3gica para restart autom\u00e1tico\nexit 1\n\nNota: Esta gu\u00eda debe actualizarse regularmente bas\u00e1ndose en los problemas m\u00e1s frecuentes encontrados en producci\u00f3n.",
    "metadata": {
        "source": "data/troubleshooting_guide.md",
        "doc_index": 4,
        "chunk_index": 95,
        "start_sentence_index": 9,
        "end_sentence_index": 9
    }
}